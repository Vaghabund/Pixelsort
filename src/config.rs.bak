use anyhow::{Context, Result};use anyhow::{Context, Result};use anyhow::{Context, Result};use anyhow::{Context, Result};use anyhow::{Context, Result};

use serde::{Deserialize, Serialize};

use std::path::{Path, PathBuf};use serde::{Deserialize, Serialize};



#[derive(Debug, Clone, Serialize, Deserialize)]use std::path::{Path, PathBuf};use serde::{Deserialize, Serialize};

pub struct Config {

    pub display: DisplayConfig,

    pub processing: ProcessingConfig,

    pub paths: PathConfig,#[derive(Debug, Clone, Serialize, Deserialize)]use std::path::{Path, PathBuf};use serde::{Deserialize, Serialize};use serde::{Deserialize, Serialize};

}

pub struct Config {

#[derive(Debug, Clone, Serialize, Deserialize)]

pub struct DisplayConfig {    pub display: DisplayConfig,

    pub width: u32,

    pub height: u32,    pub processing: ProcessingConfig,

    pub fullscreen: bool,

    pub image_display_width: u32,    pub paths: PathConfig,#[derive(Debug, Clone, Serialize, Deserialize)]use std::path::{Path, PathBuf};use std::path::{Path, PathBuf};

    pub image_display_height: u32,

}}



#[derive(Debug, Clone, Serialize, Deserialize, Default)]pub struct Config {

pub struct ProcessingConfig {

    pub default_threshold: f32,#[derive(Debug, Clone, Serialize, Deserialize)]

    pub default_interval: usize,

    pub max_image_width: u32,pub struct DisplayConfig {    pub display: DisplayConfig,

    pub max_image_height: u32,

    pub preview_scale_factor: u32,    pub width: u32,

}

    pub height: u32,    pub processing: ProcessingConfig,

#[derive(Debug, Clone, Serialize, Deserialize)]

pub struct PathConfig {    pub fullscreen: bool,

    pub sample_images_dir: PathBuf,

    pub default_save_dir: PathBuf,    pub image_display_width: u32,    pub paths: PathConfig,#[derive(Debug, Clone, Serialize, Deserialize)]#[derive(Debug, Clone, Serialize, Deserialize)]

    pub config_file: PathBuf,

}    pub image_display_height: u32,



impl Default for Config {}}

    fn default() -> Self {

        Config {

            display: DisplayConfig {

                width: 1024,#[derive(Debug, Clone, Serialize, Deserialize, Default)]pub struct Config {pub struct Config {

                height: 600,

                fullscreen: false,pub struct ProcessingConfig {

                image_display_width: 800,

                image_display_height: 480,    pub default_threshold: f32,#[derive(Debug, Clone, Serialize, Deserialize)]

            },

            processing: ProcessingConfig {    pub default_interval: usize,

                default_threshold: 50.0,

                default_interval: 10,    pub max_image_width: u32,pub struct DisplayConfig {    pub display: DisplayConfig,    pub display: DisplayConfig,

                max_image_width: 1920,

                max_image_height: 1080,    pub max_image_height: u32,

                preview_scale_factor: 4,

            },    pub preview_scale_factor: u32,    pub width: u32,

            paths: PathConfig {

                sample_images_dir: PathBuf::from("sample_images"),}

                default_save_dir: PathBuf::from("output"),

                config_file: PathBuf::from("pixelsort_config.toml"),    pub height: u32,    pub processing: ProcessingConfig,    pub processing: ProcessingConfig,

            },

        }#[derive(Debug, Clone, Serialize, Deserialize)]

    }

}pub struct PathConfig {    pub fullscreen: bool,



impl Config {    pub sample_images_dir: PathBuf,

    pub fn load() -> Result<Self> {

        let config_path = PathBuf::from("pixelsort_config.toml");    pub default_save_dir: PathBuf,    pub image_display_width: u32,    pub paths: PathConfig,    pub paths: PathConfig,

        

        if config_path.exists() {    pub config_file: PathBuf,

            Self::load_from_file(&config_path)

        } else {}    pub image_display_height: u32,

            log::info!("Configuration file not found, using default settings");

            let config = Self::default();

            config.save_to_file(&config_path)?;

            Ok(config)impl Default for Config {}}}

        }

    }    fn default() -> Self {



    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {        Config {

        let config_str = std::fs::read_to_string(path.as_ref())

            .with_context(|| format!("Failed to read config file: {}", path.as_ref().display()))?;            display: DisplayConfig {

        

        let config: Config = toml::from_str(&config_str)                width: 1024,#[derive(Debug, Clone, Serialize, Deserialize, Default)]

            .with_context(|| "Failed to parse config file")?;

                        height: 600,

        config.validate()?;

        log::info!("Configuration loaded from {}", path.as_ref().display());                fullscreen: false,pub struct ProcessingConfig {

        Ok(config)

    }                image_display_width: 800,



    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {                image_display_height: 480,    pub default_threshold: f32,#[derive(Debug, Clone, Serialize, Deserialize)]#[derive(Debug, Clone, Serialize, Deserialize)]

        let config_str = toml::to_string_pretty(self)

            .with_context(|| "Failed to serialize config")?;            },

        

        if let Some(parent) = path.as_ref().parent() {            processing: ProcessingConfig {    pub default_interval: usize,

            std::fs::create_dir_all(parent)

                .with_context(|| format!("Failed to create config directory: {}", parent.display()))?;                default_threshold: 50.0,

        }

                        default_interval: 10,    pub max_image_width: u32,pub struct DisplayConfig {pub struct DisplayConfig {

        std::fs::write(path.as_ref(), config_str)

            .with_context(|| format!("Failed to write config file: {}", path.as_ref().display()))?;                max_image_width: 1920,

        

        log::info!("Configuration saved to {}", path.as_ref().display());                max_image_height: 1080,    pub max_image_height: u32,

        Ok(())

    }                preview_scale_factor: 4,



    pub fn validate(&self) -> Result<()> {            },    pub preview_scale_factor: u32,    pub width: u32,    pub width: u32,

        if self.display.width == 0 || self.display.height == 0 {

            return Err(anyhow::anyhow!("Invalid display dimensions"));            paths: PathConfig {

        }

                sample_images_dir: PathBuf::from("sample_images"),}

        if self.display.image_display_width > self.display.width || 

           self.display.image_display_height > self.display.height {                default_save_dir: PathBuf::from("output"),

            return Err(anyhow::anyhow!("Image display size larger than screen"));

        }                config_file: PathBuf::from("pixelsort_config.toml"),    pub height: u32,    pub height: u32,



        if self.processing.default_threshold < 0.0 || self.processing.default_threshold > 255.0 {            },

            return Err(anyhow::anyhow!("Invalid default threshold"));

        }        }#[derive(Debug, Clone, Serialize, Deserialize)]



        if self.processing.default_interval == 0 {    }

            return Err(anyhow::anyhow!("Invalid default interval"));

        }}pub struct PathConfig {    pub fullscreen: bool,    pub fullscreen: bool,



        Ok(())

    }

impl Config {    pub sample_images_dir: PathBuf,

    pub fn create_directories(&self) -> Result<()> {

        std::fs::create_dir_all(&self.paths.sample_images_dir)    pub fn load() -> Result<Self> {

            .with_context(|| format!("Failed to create sample images directory: {}", 

                self.paths.sample_images_dir.display()))?;        let config_path = PathBuf::from("pixelsort_config.toml");    pub default_save_dir: PathBuf,    pub image_display_width: u32,    pub image_display_width: u32,



        std::fs::create_dir_all(&self.paths.default_save_dir)        

            .with_context(|| format!("Failed to create save directory: {}", 

                self.paths.default_save_dir.display()))?;        if config_path.exists() {    pub config_file: PathBuf,



        Ok(())            Self::load_from_file(&config_path)

    }

}        } else {}    pub image_display_height: u32,    pub image_display_height: u32,



pub struct ConfigBuilder {            log::info!("Configuration file not found, using default settings");

    config: Config,

}            let config = Self::default();



impl ConfigBuilder {            config.save_to_file(&config_path)?;

    pub fn new() -> Self {

        Self {            Ok(config)impl Default for Config {}}

            config: Config::default(),

        }        }

    }

    }    fn default() -> Self {

    pub fn display_size(mut self, width: u32, height: u32) -> Self {

        self.config.display.width = width;

        self.config.display.height = height;

        self    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {        Config {

    }

        let config_str = std::fs::read_to_string(path.as_ref())

    pub fn fullscreen(mut self, fullscreen: bool) -> Self {

        self.config.display.fullscreen = fullscreen;            .with_context(|| format!("Failed to read config file: {}", path.as_ref().display()))?;            display: DisplayConfig {

        self

    }        



    pub fn image_display_size(mut self, width: u32, height: u32) -> Self {        let config: Config = toml::from_str(&config_str)                width: 1024,#[derive(Debug, Clone, Serialize, Deserialize, Default)]#[derive(Debug, Clone, Serialize, Deserialize, Default)]

        self.config.display.image_display_width = width;

        self.config.display.image_display_height = height;            .with_context(|| "Failed to parse config file")?;

        self

    }                        height: 600,



    pub fn max_image_size(mut self, width: u32, height: u32) -> Self {        config.validate()?;

        self.config.processing.max_image_width = width;

        self.config.processing.max_image_height = height;        log::info!("Configuration loaded from {}", path.as_ref().display());                fullscreen: false,pub struct ProcessingConfig {pub struct ProcessingConfig {

        self

    }        Ok(config)



    pub fn default_threshold(mut self, threshold: f32) -> Self {    }                image_display_width: 800,

        self.config.processing.default_threshold = threshold;

        self

    }

    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {                image_display_height: 480,    pub default_threshold: f32,use std::path::{Path, PathBuf};

    pub fn build(self) -> Result<Config> {

        self.config.validate()?;        let config_str = toml::to_string_pretty(self)

        Ok(self.config)

    }            .with_context(|| "Failed to serialize config")?;            },

}

        

impl Config {

    pub fn raspberry_pi_7inch() -> Self {        if let Some(parent) = path.as_ref().parent() {            processing: ProcessingConfig {    pub default_interval: usize,

        Config {

            display: DisplayConfig {            std::fs::create_dir_all(parent)

                width: 800,

                height: 480,                .with_context(|| format!("Failed to create config directory: {}", parent.display()))?;                default_threshold: 50.0,

                fullscreen: true,

                image_display_width: 480,        }

                image_display_height: 360,

            },                        default_interval: 10,    pub max_image_width: u32,#[derive(Debug, Clone, Serialize, Deserialize)]

            ..Default::default()

        }        std::fs::write(path.as_ref(), config_str)

    }

            .with_context(|| format!("Failed to write config file: {}", path.as_ref().display()))?;                max_image_width: 1920,

    pub fn desktop_development() -> Self {

        Config {        

            display: DisplayConfig {

                width: 1024,        log::info!("Configuration saved to {}", path.as_ref().display());                max_image_height: 1080,    pub max_image_height: u32,pub struct Config {

                height: 768,

                fullscreen: false,        Ok(())

                image_display_width: 600,

                image_display_height: 450,    }                preview_scale_factor: 4,

            },

            ..Default::default()

        }

    }    pub fn validate(&self) -> Result<()> {            },    pub preview_scale_factor: u32,    pub display: DisplayConfig,



    pub fn raspberry_pi_hdmi() -> Self {        if self.display.width == 0 || self.display.height == 0 {

        Config {

            display: DisplayConfig {            return Err(anyhow::anyhow!("Invalid display dimensions"));            paths: PathConfig {

                width: 1920,

                height: 1080,        }

                fullscreen: true,

                image_display_width: 1200,                sample_images_dir: PathBuf::from("sample_images"),}    pub processing: ProcessingConfig,

                image_display_height: 900,

            },        if self.display.image_display_width > self.display.width || 

            ..Default::default()

        }           self.display.image_display_height > self.display.height {                default_save_dir: PathBuf::from("output"),

    }

}            return Err(anyhow::anyhow!("Image display size larger than screen"));

        }                config_file: PathBuf::from("pixelsort_config.toml"),    pub paths: PathConfig,



        if self.processing.default_threshold < 0.0 || self.processing.default_threshold > 255.0 {            },

            return Err(anyhow::anyhow!("Invalid default threshold"));

        }        }#[derive(Debug, Clone, Serialize, Deserialize)]}



        if self.processing.default_interval == 0 {    }

            return Err(anyhow::anyhow!("Invalid default interval"));

        }}pub struct PathConfig {



        Ok(())

    }

impl Config {    pub sample_images_dir: PathBuf,#[derive(Debug, Clone, Serialize, Deserialize)]

    pub fn create_directories(&self) -> Result<()> {

        std::fs::create_dir_all(&self.paths.sample_images_dir)    pub fn load() -> Result<Self> {

            .with_context(|| format!("Failed to create sample images directory: {}", 

                self.paths.sample_images_dir.display()))?;        let config_path = PathBuf::from("pixelsort_config.toml");    pub default_save_dir: PathBuf,pub struct DisplayConfig {



        std::fs::create_dir_all(&self.paths.default_save_dir)        

            .with_context(|| format!("Failed to create save directory: {}", 

                self.paths.default_save_dir.display()))?;        if config_path.exists() {    pub config_file: PathBuf,    pub width: u32,



        Ok(())            Self::load_from_file(&config_path)

    }

}        } else {}    pub height: u32,



pub struct ConfigBuilder {            log::info!("Configuration file not found, using default settings");

    config: Config,

}            let config = Self::default();    pub fullscreen: bool,



impl ConfigBuilder {            config.save_to_file(&config_path)?;

    pub fn new() -> Self {

        Self {            Ok(config)impl Default for Config {    pub image_display_width: u32,

            config: Config::default(),

        }        }

    }

    }    fn default() -> Self {    pub image_display_height: u32,

    pub fn display_size(mut self, width: u32, height: u32) -> Self {

        self.config.display.width = width;

        self.config.display.height = height;

        self    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {        Config {}

    }

        let config_str = std::fs::read_to_string(path.as_ref())

    pub fn fullscreen(mut self, fullscreen: bool) -> Self {

        self.config.display.fullscreen = fullscreen;            .with_context(|| format!("Failed to read config file: {}", path.as_ref().display()))?;            display: DisplayConfig {

        self

    }        



    pub fn image_display_size(mut self, width: u32, height: u32) -> Self {        let config: Config = toml::from_str(&config_str)                width: 1024,

        self.config.display.image_display_width = width;

        self.config.display.image_display_height = height;            .with_context(|| "Failed to parse config file")?;

        self

    }                        height: 600,



    pub fn max_image_size(mut self, width: u32, height: u32) -> Self {        config.validate()?;

        self.config.processing.max_image_width = width;

        self.config.processing.max_image_height = height;        log::info!("Configuration loaded from {}", path.as_ref().display());                fullscreen: false,#[derive(Debug, Clone, Serialize, Deserialize, Default)]

        self

    }        Ok(config)



    pub fn default_threshold(mut self, threshold: f32) -> Self {    }                image_display_width: 800,pub struct ProcessingConfig {

        self.config.processing.default_threshold = threshold;

        self

    }

    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {                image_display_height: 480,    pub default_threshold: f32,

    pub fn build(self) -> Result<Config> {

        self.config.validate()?;        let config_str = toml::to_string_pretty(self)

        Ok(self.config)

    }            .with_context(|| "Failed to serialize config")?;            },    pub default_interval: usize,

}

        

impl Config {

    pub fn raspberry_pi_7inch() -> Self {        // Ensure parent directory exists            processing: ProcessingConfig {    pub max_image_width: u32,

        Config {

            display: DisplayConfig {        if let Some(parent) = path.as_ref().parent() {

                width: 800,

                height: 480,            std::fs::create_dir_all(parent)                default_threshold: 50.0,    pub max_image_height: u32,

                fullscreen: true,

                image_display_width: 480,                .with_context(|| format!("Failed to create config directory: {}", parent.display()))?;

                image_display_height: 360,

            },        }                default_interval: 10,    pub preview_scale_factor: u32,

            ..Default::default()

        }        

    }

        std::fs::write(path.as_ref(), config_str)                max_image_width: 1920,}

    pub fn desktop_development() -> Self {

        Config {            .with_context(|| format!("Failed to write config file: {}", path.as_ref().display()))?;

            display: DisplayConfig {

                width: 1024,                        max_image_height: 1080,

                height: 768,

                fullscreen: false,        log::info!("Configuration saved to {}", path.as_ref().display());

                image_display_width: 600,

                image_display_height: 450,        Ok(())                preview_scale_factor: 4,#[derive(Debug, Clone, Serialize, Deserialize)]

            },

            ..Default::default()    }

        }

    }            },pub struct PathConfig {



    pub fn raspberry_pi_hdmi() -> Self {    pub fn validate(&self) -> Result<()> {

        Config {

            display: DisplayConfig {        // Validate display settings            paths: PathConfig {    pub sample_images_dir: PathBuf,

                width: 1920,

                height: 1080,        if self.display.width == 0 || self.display.height == 0 {

                fullscreen: true,

                image_display_width: 1200,            return Err(anyhow::anyhow!("Invalid display dimensions"));                sample_images_dir: PathBuf::from("sample_images"),    pub default_save_dir: PathBuf,

                image_display_height: 900,

            },        }

            ..Default::default()

        }                default_save_dir: PathBuf::from("output"),    pub config_file: PathBuf,

    }

}        if self.display.image_display_width > self.display.width || 



#[cfg(test)]           self.display.image_display_height > self.display.height {                config_file: PathBuf::from("pixelsort_config.toml"),}

mod tests {

    use super::*;            return Err(anyhow::anyhow!("Image display size larger than screen"));

    use tempfile::TempDir;

        }            },

    #[test]

    fn test_config_builder() {

        let config = ConfigBuilder::new()

            .display_size(1024, 768)        // Validate processing settings        }impl Default for Config {

            .fullscreen(false)

            .default_threshold(75.0)        if self.processing.default_threshold < 0.0 || self.processing.default_threshold > 255.0 {

            .build()

            .unwrap();            return Err(anyhow::anyhow!("Invalid default threshold"));    }    fn default() -> Self {



        assert_eq!(config.display.width, 1024);        }

        assert_eq!(config.display.height, 768);

        assert!(!config.display.fullscreen);}        Self {

        assert_eq!(config.processing.default_threshold, 75.0);

    }        if self.processing.default_interval == 0 {



    #[test]            return Err(anyhow::anyhow!("Invalid default interval"));            display: DisplayConfig {

    fn test_config_validation() {

        let mut config = Config::default();        }

        

        config.processing.default_threshold = 300.0;impl Config {                width: 800,

        assert!(config.validate().is_err());

                Ok(())

        config.processing.default_threshold = 50.0;

        assert!(config.validate().is_ok());    }    pub fn load() -> Result<Self> {                height: 480,

    }



    #[test]

    fn test_config_save_load() {    pub fn create_directories(&self) -> Result<()> {        let config_path = PathBuf::from("pixelsort_config.toml");                fullscreen: true,

        let temp_dir = TempDir::new().unwrap();

        let config_path = temp_dir.path().join("test_config.toml");        // Create sample images directory

        

        let original_config = Config::raspberry_pi_7inch();        std::fs::create_dir_all(&self.paths.sample_images_dir)                        image_display_width: 480,

        original_config.save_to_file(&config_path).unwrap();

                    .with_context(|| format!("Failed to create sample images directory: {}", 

        let loaded_config = Config::load_from_file(&config_path).unwrap();

                        self.paths.sample_images_dir.display()))?;        if config_path.exists() {                image_display_height: 360,

        assert_eq!(original_config.display.width, loaded_config.display.width);

        assert_eq!(original_config.display.height, loaded_config.display.height);

    }

        // Create default save directory            Self::load_from_file(&config_path)            },

    #[test]

    fn test_preset_configs() {        std::fs::create_dir_all(&self.paths.default_save_dir)

        let pi_config = Config::raspberry_pi_7inch();

        assert_eq!(pi_config.display.width, 800);            .with_context(|| format!("Failed to create save directory: {}",         } else {            gpio: GpioConfig {

        assert_eq!(pi_config.display.height, 480);

        assert!(pi_config.display.fullscreen);                self.paths.default_save_dir.display()))?;



        let desktop_config = Config::desktop_development();            log::info!("Configuration file not found, using default settings");                enabled: true,

        assert_eq!(desktop_config.display.width, 1024);

        assert_eq!(desktop_config.display.height, 768);        Ok(())

        assert!(!desktop_config.display.fullscreen);

    }    }            let config = Self::default();                debounce_ms: 200,

}
}

            config.save_to_file(&config_path)?;                pins: GpioPins {

// Configuration builder pattern for easy setup

pub struct ConfigBuilder {            Ok(config)                    load_image: 18,

    config: Config,

}        }                    next_algorithm: 19,



impl ConfigBuilder {    }                    threshold_up: 20,

    pub fn new() -> Self {

        Self {                    threshold_down: 21,

            config: Config::default(),

        }    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {                    save_image: 26,

    }

        let config_str = std::fs::read_to_string(path.as_ref())                },

    pub fn display_size(mut self, width: u32, height: u32) -> Self {

        self.config.display.width = width;            .with_context(|| format!("Failed to read config file: {}", path.as_ref().display()))?;            },

        self.config.display.height = height;

        self                    processing: ProcessingConfig {

    }

        let config: Config = toml::from_str(&config_str)                default_threshold: 50.0,

    pub fn fullscreen(mut self, fullscreen: bool) -> Self {

        self.config.display.fullscreen = fullscreen;            .with_context(|| "Failed to parse config file")?;                default_interval: 10,

        self

    }                        max_image_width: 1920,



    pub fn image_display_size(mut self, width: u32, height: u32) -> Self {        config.validate()?;                max_image_height: 1080,

        self.config.display.image_display_width = width;

        self.config.display.image_display_height = height;        log::info!("Configuration loaded from {}", path.as_ref().display());                preview_scale_factor: 4,

        self

    }        Ok(config)            },



    pub fn max_image_size(mut self, width: u32, height: u32) -> Self {    }            paths: PathConfig {

        self.config.processing.max_image_width = width;

        self.config.processing.max_image_height = height;                sample_images_dir: PathBuf::from("sample_images"),

        self

    }    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {                default_save_dir: PathBuf::from("output"),



    pub fn default_threshold(mut self, threshold: f32) -> Self {        let config_str = toml::to_string_pretty(self)                config_file: PathBuf::from("pixelsort_config.toml"),

        self.config.processing.default_threshold = threshold;

        self            .with_context(|| "Failed to serialize config")?;            },

    }

                }

    pub fn build(self) -> Result<Config> {

        self.config.validate()?;        std::fs::write(path.as_ref(), config_str)    }

        Ok(self.config)

    }            .with_context(|| format!("Failed to write config file: {}", path.as_ref().display()))?;}

}

        

// Environment-specific configuration presets

impl Config {        Ok(())impl Config {

    pub fn raspberry_pi_7inch() -> Self {

        Config {    }    pub fn load() -> Result<Self> {

            display: DisplayConfig {

                width: 800,        let config_path = PathBuf::from("pixelsort_config.toml");

                height: 480,

                fullscreen: true,    pub fn validate(&self) -> Result<()> {        

                image_display_width: 480,

                image_display_height: 360,        // Validate display settings        if config_path.exists() {

            },

            ..Default::default()        if self.display.width == 0 || self.display.height == 0 {            Self::load_from_file(&config_path)

        }

    }            return Err(anyhow::anyhow!("Invalid display dimensions"));        } else {



    pub fn desktop_development() -> Self {        }            log::info!("Config file not found, creating default configuration");

        Config {

            display: DisplayConfig {            let default_config = Self::default();

                width: 1024,

                height: 768,        if self.display.image_display_width > self.display.width ||             default_config.save()?;

                fullscreen: false,

                image_display_width: 600,           self.display.image_display_height > self.display.height {            Ok(default_config)

                image_display_height: 450,

            },            return Err(anyhow::anyhow!("Image display size larger than screen"));        }

            ..Default::default()

        }        }    }

    }



    pub fn raspberry_pi_hdmi() -> Self {

        Config {        // Validate processing settings    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {

            display: DisplayConfig {

                width: 1920,        if self.processing.default_threshold < 0.0 || self.processing.default_threshold > 255.0 {        let contents = std::fs::read_to_string(path.as_ref())

                height: 1080,

                fullscreen: true,            return Err(anyhow::anyhow!("Invalid default threshold"));            .with_context(|| format!("Failed to read config file: {}", path.as_ref().display()))?;

                image_display_width: 1200,

                image_display_height: 900,        }        

            },

            ..Default::default()        let config: Self = toml::from_str(&contents)

        }

    }        if self.processing.default_interval == 0 {            .with_context(|| "Failed to parse configuration file")?;

}

            return Err(anyhow::anyhow!("Invalid default interval"));        

#[cfg(test)]

mod tests {        }        log::info!("Configuration loaded from {}", path.as_ref().display());

    use super::*;

    use tempfile::TempDir;        Ok(config)



    #[test]        Ok(())    }

    fn test_config_builder() {

        let config = ConfigBuilder::new()    }

            .display_size(1024, 768)

            .fullscreen(false)    pub fn save(&self) -> Result<()> {

            .default_threshold(75.0)

            .build()    pub fn create_directories(&self) -> Result<()> {        self.save_to_file(&self.paths.config_file)

            .unwrap();

        // Create sample images directory    }

        assert_eq!(config.display.width, 1024);

        assert_eq!(config.display.height, 768);        std::fs::create_dir_all(&self.paths.sample_images_dir)

        assert!(!config.display.fullscreen);

        assert_eq!(config.processing.default_threshold, 75.0);            .with_context(|| format!("Failed to create sample images directory: {}",     pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {

    }

                self.paths.sample_images_dir.display()))?;        let contents = toml::to_string_pretty(self)

    #[test]

    fn test_config_validation() {            .context("Failed to serialize configuration")?;

        let mut config = Config::default();

                // Create default save directory        

        // Test invalid threshold

        config.processing.default_threshold = 300.0;        std::fs::create_dir_all(&self.paths.default_save_dir)        // Ensure parent directory exists

        assert!(config.validate().is_err());

                    .with_context(|| format!("Failed to create save directory: {}",         if let Some(parent) = path.as_ref().parent() {

        // Reset threshold for other tests

        config.processing.default_threshold = 50.0;                self.paths.default_save_dir.display()))?;            std::fs::create_dir_all(parent)

        assert!(config.validate().is_ok());

    }                .with_context(|| format!("Failed to create config directory: {}", parent.display()))?;



    #[test]        Ok(())        }

    fn test_config_save_load() {

        let temp_dir = TempDir::new().unwrap();    }

        let config_path = temp_dir.path().join("test_config.toml");

        }        std::fs::write(path.as_ref(), contents)

        let original_config = Config::raspberry_pi_7inch();

        original_config.save_to_file(&config_path).unwrap();            .with_context(|| format!("Failed to write config file: {}", path.as_ref().display()))?;

        

        let loaded_config = Config::load_from_file(&config_path).unwrap();// Configuration builder pattern for easy setup        

        

        assert_eq!(original_config.display.width, loaded_config.display.width);pub struct ConfigBuilder {        log::info!("Configuration saved to {}", path.as_ref().display());

        assert_eq!(original_config.display.height, loaded_config.display.height);

    }    config: Config,        Ok(())



    #[test]}    }

    fn test_preset_configs() {

        let pi_config = Config::raspberry_pi_7inch();

        assert_eq!(pi_config.display.width, 800);

        assert_eq!(pi_config.display.height, 480);impl ConfigBuilder {    pub fn validate(&self) -> Result<()> {

        assert!(pi_config.display.fullscreen);

    pub fn new() -> Self {        // Validate display settings

        let desktop_config = Config::desktop_development();

        assert_eq!(desktop_config.display.width, 1024);        Self {        if self.display.width == 0 || self.display.height == 0 {

        assert_eq!(desktop_config.display.height, 768);

        assert!(!desktop_config.display.fullscreen);            config: Config::default(),            return Err(anyhow::anyhow!("Invalid display dimensions"));

    }

}        }        }

    }

        if self.display.image_display_width > self.display.width || 

    pub fn display_size(mut self, width: u32, height: u32) -> Self {           self.display.image_display_height > self.display.height {

        self.config.display.width = width;            return Err(anyhow::anyhow!("Image display area larger than screen"));

        self.config.display.height = height;        }

        self

    }        // Validate processing settings

        if self.processing.default_threshold < 0.0 || self.processing.default_threshold > 255.0 {

    pub fn fullscreen(mut self, fullscreen: bool) -> Self {            return Err(anyhow::anyhow!("Invalid default threshold"));

        self.config.display.fullscreen = fullscreen;        }

        self

    }        if self.processing.default_interval == 0 {

            return Err(anyhow::anyhow!("Invalid default interval"));

    pub fn image_display_size(mut self, width: u32, height: u32) -> Self {        }

        self.config.display.image_display_width = width;

        self.config.display.image_display_height = height;

        self

    }        Ok(())

    }

    pub fn max_image_size(mut self, width: u32, height: u32) -> Self {

        self.config.processing.max_image_width = width;    pub fn create_directories(&self) -> Result<()> {

        self.config.processing.max_image_height = height;        // Create sample images directory

        self        std::fs::create_dir_all(&self.paths.sample_images_dir)

    }            .with_context(|| format!("Failed to create sample images directory: {}", 

                self.paths.sample_images_dir.display()))?;

    pub fn default_threshold(mut self, threshold: f32) -> Self {

        self.config.processing.default_threshold = threshold;        // Create default save directory

        self        std::fs::create_dir_all(&self.paths.default_save_dir)

    }            .with_context(|| format!("Failed to create save directory: {}", 

                self.paths.default_save_dir.display()))?;

    pub fn build(self) -> Result<Config> {

        self.config.validate()?;        log::info!("Created necessary directories");

        Ok(self.config)        Ok(())

    }    }

}

    // Helper methods for common operations

// Environment-specific configuration presets    pub fn get_display_aspect_ratio(&self) -> f32 {

impl Config {        self.display.width as f32 / self.display.height as f32

    pub fn raspberry_pi_7inch() -> Self {    }

        Config {

            display: DisplayConfig {    pub fn get_image_display_aspect_ratio(&self) -> f32 {

                width: 800,        self.display.image_display_width as f32 / self.display.image_display_height as f32

                height: 480,    }

                fullscreen: true,

                image_display_width: 480,    pub fn is_raspberry_pi_resolution(&self) -> bool {

                image_display_height: 360,        // Common Raspberry Pi display resolutions

            },        matches!(

            ..Default::default()            (self.display.width, self.display.height),

        }            (800, 480) | (1024, 600) | (1280, 720) | (1920, 1080)

    }        )

    }

    pub fn desktop_development() -> Self {

        Config {    pub fn update_display_size(&mut self, width: u32, height: u32) -> Result<()> {

            display: DisplayConfig {        if width == 0 || height == 0 {

                width: 1024,            return Err(anyhow::anyhow!("Invalid display dimensions: {}x{}", width, height));

                height: 768,        }

                fullscreen: false,

                image_display_width: 600,        self.display.width = width;

                image_display_height: 450,        self.display.height = height;

            },        

            ..Default::default()        // Automatically adjust image display area to maintain reasonable proportions

        }        self.display.image_display_width = (width as f32 * 0.6) as u32;

    }        self.display.image_display_height = (height as f32 * 0.75) as u32;

        

    pub fn raspberry_pi_hdmi() -> Self {        log::info!("Updated display configuration to {}x{}", width, height);

        Config {        Ok(())

            display: DisplayConfig {    }

                width: 1920,}

                height: 1080,

                fullscreen: true,// Configuration builder for easier setup

                image_display_width: 1200,pub struct ConfigBuilder {

                image_display_height: 900,    config: Config,

            },}

            ..Default::default()

        }impl ConfigBuilder {

    }    pub fn new() -> Self {

}        Self {

            config: Config::default(),

#[cfg(test)]        }

mod tests {    }

    use super::*;

    use tempfile::TempDir;    pub fn display_size(mut self, width: u32, height: u32) -> Self {

        self.config.display.width = width;

    #[test]        self.config.display.height = height;

    fn test_config_builder() {        self

        let config = ConfigBuilder::new()    }

            .display_size(1024, 768)

            .fullscreen(false)    pub fn fullscreen(mut self, enabled: bool) -> Self {

            .default_threshold(75.0)        self.config.display.fullscreen = enabled;

            .build()        self

            .unwrap();    }



        assert_eq!(config.display.width, 1024);

        assert_eq!(config.display.height, 768);

        assert!(!config.display.fullscreen);    pub fn max_image_size(mut self, width: u32, height: u32) -> Self {

        assert_eq!(config.processing.default_threshold, 75.0);        self.config.processing.max_image_width = width;

    }        self.config.processing.max_image_height = height;

        self

    #[test]    }

    fn test_config_validation() {

        let mut config = Config::default();    pub fn default_threshold(mut self, threshold: f32) -> Self {

                self.config.processing.default_threshold = threshold;

        // Test invalid threshold        self

        config.processing.default_threshold = 300.0;    }

        assert!(config.validate().is_err());

            pub fn build(self) -> Result<Config> {

        // Reset threshold for other tests        self.config.validate()?;

        config.processing.default_threshold = 50.0;        Ok(self.config)

    }    }

}

    #[test]

    fn test_config_save_load() {// Environment-specific configuration presets

        let temp_dir = TempDir::new().unwrap();impl Config {

        let config_path = temp_dir.path().join("test_config.toml");    pub fn raspberry_pi_7inch() -> Self {

                Config {

        let original_config = Config::raspberry_pi_7inch();            display: DisplayConfig {

        original_config.save_to_file(&config_path).unwrap();                width: 800,

                        height: 480,

        let loaded_config = Config::load_from_file(&config_path).unwrap();                fullscreen: true,

                        image_display_width: 480,

        assert_eq!(original_config.display.width, loaded_config.display.width);                image_display_height: 360,

        assert_eq!(original_config.display.height, loaded_config.display.height);            },

    }            ..Default::default()

        }

    #[test]    }

    fn test_preset_configs() {

        let pi_config = Config::raspberry_pi_7inch();    pub fn development_desktop() -> Self {

        assert_eq!(pi_config.display.width, 800);        Config {

        assert_eq!(pi_config.display.height, 480);            display: DisplayConfig {

        assert!(pi_config.display.fullscreen);                width: 1024,

                height: 768,

        let desktop_config = Config::desktop_development();                fullscreen: false,

        assert_eq!(desktop_config.display.width, 1024);                image_display_width: 600,

        assert_eq!(desktop_config.display.height, 768);                image_display_height: 450,

        assert!(!desktop_config.display.fullscreen);            },

    }            ..Default::default()

}        }
    }

    pub fn raspberry_pi_hdmi() -> Self {
        Config {
            display: DisplayConfig {
                width: 1920,
                height: 1080,
                fullscreen: true,
                image_display_width: 1200,
                image_display_height: 900,
            },
            processing: ProcessingConfig {
                max_image_width: 2560,
                max_image_height: 1440,
                ..ProcessingConfig::default()
            },
            ..Default::default()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_default_config() {
        let config = Config::default();
        assert!(config.validate().is_ok());
        assert!(config.is_raspberry_pi_resolution());
    }

    #[test]
    fn test_config_builder() {
        let config = ConfigBuilder::new()
            .display_size(1024, 768)
            .fullscreen(false)
            .default_threshold(75.0)
            .build()
            .unwrap();

        assert_eq!(config.display.width, 1024);
        assert_eq!(config.display.height, 768);
        assert!(!config.display.fullscreen);
        assert_eq!(config.processing.default_threshold, 75.0);
    }

    #[test]
    fn test_config_validation() {
        let mut config = Config::default();
        
        // Test invalid threshold
        config.processing.default_threshold = 300.0;
        assert!(config.validate().is_err());
        
        // Reset threshold for other tests
        config.processing.default_threshold = 50.0;
    }

    #[test]
    fn test_config_save_load() {
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("test_config.toml");
        
        let original_config = Config::raspberry_pi_7inch();
        original_config.save_to_file(&config_path).unwrap();
        
        let loaded_config = Config::load_from_file(&config_path).unwrap();
        
        assert_eq!(original_config.display.width, loaded_config.display.width);
        assert_eq!(original_config.display.height, loaded_config.display.height);
    }

    #[test]
    fn test_preset_configs() {
        assert!(Config::raspberry_pi_7inch().validate().is_ok());
        assert!(Config::development_desktop().validate().is_ok());
        assert!(Config::raspberry_pi_hdmi().validate().is_ok());
    }
}